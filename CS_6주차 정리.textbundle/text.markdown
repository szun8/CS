# 자료구조

## 1. 복잡도

### 시간복잡도
- 코딩테스트에서 관행적인 시간 10^8이내로 문제를 해결하면 시간초과는 발생하지 않을 것이다
	물론 테스트하는 CPU의 성능 차이는 보이겠지만 대략 코테 문제들은 최대 2초 이내로 문제를 풀라고 하는 경우가 많다 (C++의경우)
	
	> 이때 입력을 기준으로 연산된 횟수가 10^8이라면 1.78초정도가 소요된다.  
	
	그래서 나는 코딩테스트를 풀때 입력값의 최대를 먼저 생각하고 시간내에 풀수있는 최대 시간복잡도 알고리즘이 무엇일까 생각하는 편이다.  
	
	이번 쉬운 최단 거리의 문제를 예로 들자.  
	시간 제한은 1초, 입력 n과 m은 1000까지이다.  
	
	우리는 이 지도를 한번씩 다 탐색하는 반복문을 실행한다고 하면 O(n*m) = O(10^6)이므로 나름 쉽게 문제를 풀수 있게 되는 것이다.  
	  

### 공간복잡도

## 2. 선형자료구조

### 배열
- 배열은 잘싸여진 포인터
- 정적 배열 `int name[100];`
	- Compile시 크기 결정
	- pointer로 주소 계산 접근
![](assets/E5CA36D6-1FE7-4AE1-93A4-1E5D11593EB7.png)
- 동적 배열 `vector<T> name;`
	- Runtime 시 크기 결정
	- iterator 반복자로 주소 접근 (++, —)
	- 보통 뒤에서 삽입, 삭제를 하는 연산을 수행
	- 인덱스로 직접접근이 가능하기에 원하는 인덱스가 있다면 O(1)
	- 검색은 앞에서부터 순차적으로 확인해야하기에 O(n)
	- Capacity vs Size
![](assets/F69B9473-1802-4038-AC57-FCF6477B6E3C.png)

### 연결리스트 `list<T>`
- 물리적으로 붙어있지 않고 포인터로 앞뒤를 가리켜 논리적 연결을 지향
	- 따라서 서로 가리키는 주소만 변경하면 되기에 삽입과 삭제연산이 자유롭다
	- 하지만 논리적 연결로 순차 접근
- head와 tail이 존재하여 리스트의 시작과 끝을 맺는다.  마지막 tail node는 NULL을 가진다 
![](assets/B9C8D394-5215-4B1B-AC82-1EF10CC4536A.png)
- 이중 연결리스트 C++
	- 가리키는 포인터가 다음만이 아닌 자기 이전 포인터도 보유 -> 양방향 탐색이 가능
![](assets/D1E31F89-9885-47B5-9E54-1EF937B4B7CF.png)
- 원형 연결 리스트
	- 마지막 tail이 null이 아니라 첫번째 노드 주소값을 저장한다. 따라서 단일 연결리스트에서 마지막에 저장하기 위해 필요했던 접근 시간이 삭제되어 보다 빠르게 마지막에 데이터를 조정할 수 있게 되었다.

### 스택 `Stack<T>`
- top위치에서 삽입과 삭제 모두 이뤄지는 자료구조

### 큐 `Queue<T>`
- front와 rear위치를 가지고 있으며 삽입은 rear, 삭제는 front

### deque
- stack + queue

## 3. 비선형자료구조

### 그래프
- 사이클이 존재하는 트리, 보통 인접그래프를 통해 그 관계를 저장
- 존재하는 간선은 방향, 무방향이 있어 연결 정보 저장 시 주의 필요
- 비용이나 가중치가 각 간선에 존재하는 경우 존재
	- 다익스트라, MST, 플로이드 워셜 
	- BFS, DFS

### 트리
- 사이클이 없는 계층적 관계
- 언어 정리
	- 루트 노드, 부모 노드, 자식 노드, 단말 노드, 형제 노드
	- 서브 트리
	- 레벨, 높이, 차수
- 종류
	- 이진 트리
		- 자식노드가 최대 2개인 노드
		- 완전 이진트리, 포화 이진트리
		- 이진 탐색트리 : 왼쪽 서브 < 루트 < 오른쪽 서브
			- 균형 이진 탐색 트리 : 레드블랙트리(map), AVL트리 (자가 균형 이진 탐색 트리)
				루트와 데이터가 없는 단말 노드는 무조건 검정색 노드이며, 빨간색 노드는 연속으로 이어져있지 않다  
				
				루트 노드에서 임의 노드까지의 경로에 검정색 노드의 개수는 각 레벨 별로 동일하다.  
				
				—  
				왼쪽과 오른쪽 서브트리의 높이 차이는 최대 1인 트리

### 우선순위 큐 `priority_queue<T>` : default 오름차순 정렬
- 최소 혹은 최대로 우선순위가 지정되어 그에 맞는 값이 dequeue되는 자료구조
	- 완전 이진트리로 구성된 heap 자료구조로 구현

### 힙 : 완전이진트리
- 최소 힙 : 루트 노드의 값이 최소인 트리
- 최대 힙 : 루트 노드의 값이 최대인 트리

### 해시테이블 `unordered_map<TKey, TValue>`
- 하나의 키와 값을 가진 형태의 자료구조
- 해시함수를 사용하여 해시테이블을 구성하고, key에 대한 해시함수의 반환값이 테이블의 인덱스이며, 그 인덱스속 데이터 값을 value로 반환한다.
- 해시 충돌
	- 체이닝 : 각은 해시 반환에 대한 값을 연결리스트에 저장
	- 개방 주소법 : 비어있는 곳에 저장
		- 선형, 이차, 이중 해싱
